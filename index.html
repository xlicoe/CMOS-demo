<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CMOS Simulator v2.8</title>

    <!--
        Project: CMOS Simulator v2.8
        Generated with: Google Gemini (Version: 2.5 Pro, Reasoning, math & code)
        Reference: https://gemini.google.com/
        Date of Final Version: August 10, 2025
        Development History: This application was built iteratively.
        v2.3-v2.8 Change: UI and visual change.
        v2.2 Change: Reworked the simulation engine to remove complex priority logic. Now, any direct contention between a HIGH and LOW pull on a net results in an ERROR state.
    -->

    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        /* Custom cursor for different modes */
        .cursor-grab { cursor: grab; }
        .cursor-grabbing { cursor: grabbing; }
        .cursor-crosshair { cursor: crosshair; }
        .cursor-pointer { cursor: pointer; }
        .cursor-trash { cursor: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><path d='M3 6h18'/><path d='M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2'/><line x1='10' y1='11' x2='10' y2='17'/><line x1='14' y1='11' x2='14' y2='17'/></svg>") 12 12, auto; }

        .palette-item {
            transition: all 0.2s ease-in-out;
        }
        .palette-item:hover {
            transform: scale(1.05);
            background-color: #3b82f6; /* blue-600 */
        }
        .palette-item.selected {
            background-color: #2563eb; /* blue-700 */
            box-shadow: 0 0 0 3px #60a5fa; /* blue-400 */
        }
        .mode-button {
            transition: all 0.2s ease-in-out;
        }
        .mode-button.active {
             background-color: #1d4ed8; /* blue-800 */
             color: white;
             box-shadow: 0 0 0 2px #3b82f6; /* blue-600 */
        }
        .mode-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .message-box {
            transition: opacity 0.5s, transform 0.5s;
        }
        #truth-table-panel {
            transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out;
            transform: translateX(0);
            opacity: 1;
        }
        #truth-table-panel.hidden {
            transform: translateX(calc(100% + 2rem));
            opacity: 0;
            pointer-events: none;
        }
        #truth-table-container table {
            width: 100%;
            border-collapse: collapse;
        }
        #truth-table-container th, #truth-table-container td {
            padding: 6px 4px;
            text-align: center;
            border: 1px solid #4b5563; /* gray-600 */
        }
        #truth-table-container th {
            background-color: #374151; /* gray-700 */
        }
        .state-high { color: #4ade80; font-weight: 600; } /* green-400 */
        .state-low { color: #f87171; font-weight: 600; } /* red-400 */
        .state-float { color: #f59e0b; } /* amber-500 */
        .state-error { color: #ef4444; background-color: #7f1d1d; } /* red-500, red-900 */
    </style>
</head>
<body class="bg-gray-900 text-gray-200 flex flex-col items-center justify-center min-h-screen p-4 overflow-hidden">

    <div class="w-full max-w-7xl h-[90vh] bg-gray-800 rounded-2xl shadow-2xl p-4 md:p-6 flex flex-col gap-4 relative">
        <header class="flex items-center justify-between">
            <div class="flex items-center gap-4">
                <div class="text-xl font-bold text-white">Coe College</div>
            </div>
            <div class="text-center">
                <h1 class="text-2xl md:text-3xl font-bold text-white">CMOS Simulator v2.8</h1>
                <p class="text-gray-400 mt-1 text-sm md:text-base">Drag components, wire them up, and see the truth table update in real-time!</p>
            </div>
            <div class="text-right">
                <p class="text-lg font-semibold text-white">ENR 325</p>
                <p class="text-sm text-gray-400">Fall 2025</p>
            </div>
        </header>

        <div class="flex-grow flex flex-col md:flex-row gap-4 min-h-0">
            <!-- Left Column: Controls & Palette -->
            <div class="w-full md:w-56 flex-shrink-0 bg-gray-900/50 rounded-xl p-4 border border-gray-700 flex flex-col gap-4">
                <h2 class="text-lg font-semibold text-center border-b border-gray-600 pb-2">Tools</h2>
                <div class="grid grid-cols-3 sm:grid-cols-2 md:grid-cols-1 gap-2">
                    <button id="tool-select" class="mode-button active flex items-center justify-center gap-2 p-2 rounded-lg bg-gray-700 hover:bg-gray-600">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 4v10a4 4 0 0 1-4 4H4"/><path d="m16 16-4 4 4 4"/><path d="M4 20V10a4 4 0 0 1 4-4h12"/></svg>
                        <span>Select</span>
                    </button>
                    <button id="tool-wire" class="mode-button flex items-center justify-center gap-2 p-2 rounded-lg bg-gray-700 hover:bg-gray-600">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14.5 16.5a3.5 3.5 0 1 1-7 0 3.5 3.5 0 0 1 7 0Z"/><path d="M12 13V2"/><path d="M12 9l3.5-3.5"/><path d="M12 9L8.5 5.5"/><path d="M19 12h-2"/><path d="M5 12H3"/><path d="M19 12l-1.5 1.5"/><path d="M5 12l1.5 1.5"/><path d="M12 22v-2"/></svg>
                        <span>Wire</span>
                    </button>
                    <button id="tool-delete" class="mode-button flex items-center justify-center gap-2 p-2 rounded-lg bg-gray-700 hover:bg-gray-600">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/><line x1="10" y1="11" x2="10" y2='17'/><line x1='14' y1='11' x2='14' y2='17'/></svg>
                        <span>Delete</span>
                    </button>
                </div>
                
                <h2 class="text-lg font-semibold text-center border-b border-gray-600 pb-2 pt-4">Components</h2>
                <div class="grid grid-cols-2 gap-2">
                    <div class="palette-item text-center p-3 rounded-lg bg-gray-700 cursor-pointer" data-type="pmos">PMOS</div>
                    <div class="palette-item text-center p-3 rounded-lg bg-gray-700 cursor-pointer" data-type="nmos">NMOS</div>
                    <div class="palette-item text-center p-3 rounded-lg bg-gray-700 cursor-pointer" data-type="input">Input</div>
                    <div class="palette-item text-center p-3 rounded-lg bg-gray-700 cursor-pointer" data-type="output">Output</div>
                    <div class="palette-item text-center p-3 rounded-lg bg-gray-700 cursor-pointer" data-type="vdd">VDD</div>
                    <div class="palette-item text-center p-3 rounded-lg bg-gray-700 cursor-pointer" data-type="gnd">GND</div>
                </div>

                <h2 class="text-lg font-semibold text-center border-b border-gray-600 pb-2 pt-4">Actions</h2>
                <div class="grid grid-cols-2 gap-2">
                     <button id="undo-button" class="mode-button flex items-center justify-center gap-2 p-2 rounded-lg bg-gray-700 hover:bg-gray-600">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 7v6h-6"/><path d="M3 17a9 9 0 0 1 9-9 9 9 0 0 1 6 2.3l-3 2.7"/></svg>
                        <span>Back</span>
                    </button>
                     <button id="redo-button" class="mode-button flex items-center justify-center gap-2 p-2 rounded-lg bg-gray-700 hover:bg-gray-600">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 7v6h6"/><path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3l3 2.7"/></svg>
                        <span>Forward</span>
                    </button>
                     <button id="copy-button" class="mode-button flex items-center justify-center gap-2 p-2 rounded-lg bg-gray-700 hover:bg-gray-600">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>
                        <span>Copy</span>
                    </button>
                     <button id="paste-button" class="mode-button flex items-center justify-center gap-2 p-2 rounded-lg bg-gray-700 hover:bg-gray-600">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path></svg>
                        <span>Paste</span>
                    </button>
                </div>
                 <button id="toggle-truth-table" class="col-span-2 mode-button active flex items-center justify-center gap-2 p-2 mt-2 rounded-lg bg-gray-700 hover:bg-gray-600">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 6h16"/><path d="M4 12h16"/><path d="M4 18h16"/></svg>
                    <span>Truth Table</span>
                </button>
                
                <div class="mt-auto space-y-2 pt-4">
                    <div class="grid grid-cols-2 gap-2">
                         <button id="save-button" class="w-full p-2 rounded-lg bg-blue-700 hover:bg-blue-600 text-white font-semibold">Save</button>
                         <button id="load-button" class="w-full p-2 rounded-lg bg-gray-600 hover:bg-gray-500 text-white font-semibold">Load</button>
                    </div>
                    <button id="clear-canvas" class="w-full p-2 rounded-lg bg-red-800 hover:bg-red-700 text-white font-semibold">Clear All</button>
                </div>
                <input type="file" id="file-input" class="hidden" accept=".json">
            </div>

            <!-- Center Column: Canvas -->
            <div class="flex-grow bg-gray-900 rounded-xl overflow-hidden border border-gray-700 relative">
                <canvas id="circuit-canvas"></canvas>
                <div id="message-box" class="message-box absolute top-4 right-4 bg-red-500 text-white p-3 rounded-lg shadow-lg opacity-0 translate-y-[-20px]">
                    <p id="message-text"></p>
                </div>
            </div>
        </div>

        <!-- Right Column: Floating Truth Table -->
        <div id="truth-table-panel" class="absolute bottom-0 right-0 w-72 max-h-[50vh] p-4 md:p-6">
            <div class="w-full h-full bg-gray-900/50 rounded-xl p-4 border border-gray-700 flex flex-col min-h-0">
                 <h2 class="text-lg font-semibold text-center border-b border-gray-600 pb-2">Truth Table</h2>
                 <div id="truth-table-container" class="overflow-auto text-sm flex-grow mt-2">
                     <!-- Table will be generated here -->
                 </div>
            </div>
        </div>
    </div>

    <script>
        // --- SETUP ---
        const canvas = document.getElementById('circuit-canvas');
        const ctx = canvas.getContext('2d');
        const toolSelect = document.getElementById('tool-select');
        const toolWire = document.getElementById('tool-wire');
        const toolDelete = document.getElementById('tool-delete');
        const undoButton = document.getElementById('undo-button');
        const redoButton = document.getElementById('redo-button');
        const copyButton = document.getElementById('copy-button');
        const pasteButton = document.getElementById('paste-button');
        const paletteItems = document.querySelectorAll('.palette-item');
        const clearButton = document.getElementById('clear-canvas');
        const saveButton = document.getElementById('save-button');
        const loadButton = document.getElementById('load-button');
        const fileInput = document.getElementById('file-input');
        const messageBox = document.getElementById('message-box');
        const messageText = document.getElementById('message-text');
        const truthTableContainer = document.getElementById('truth-table-container');
        const truthTablePanel = document.getElementById('truth-table-panel');
        const toggleTruthTableButton = document.getElementById('toggle-truth-table');

        // --- GLOBAL STATE ---
        const GRID_SIZE = 20;
        const STATE_HIGH = 1;
        const STATE_LOW = -1;
        const STATE_FLOAT = 0;
        const STATE_ERROR = 99;

        let state = {
            mode: 'select',
            placingComponentType: null,
            dragging: false,
            wiringStartPoint: null,
            mouseX: 0,
            mouseY: 0,
            dragStartX: 0,
            dragStartY: 0,
            selectionBox: null,
            components: [],
            wires: [],
            joints: [],
            nextInputLabel: 'A',
            nextId: 0,
        };
        let history = [];
        let historyIndex = -1;
        let clipboard = null;

        const colors = {
            wireOff: '#4b5563', wireOn: '#22c55e', wireFloat: '#f59e0b', wireError: '#ef4444',
            text: '#e5e7eb', pmos: '#f43f5e', nmos: '#3b82f6',
            componentStroke: '#9ca3af', terminal: '#cbd5e1', terminalHighlight: '#60a5fa',
            joint: '#f59e0b', grid: '#374151', selection: 'rgba(96, 165, 250, 0.3)'
        };

        // --- UTILITY & HELPER FUNCTIONS ---
        
        function getMousePos(evt) {
            const rect = canvas.getBoundingClientRect();
            return { x: evt.clientX - rect.left, y: evt.clientY - rect.top };
        }

        function snapToGrid(value) {
            return Math.round(value / GRID_SIZE) * GRID_SIZE;
        }

        function showMessage(text, duration = 3000, isError = false) {
            messageText.textContent = text;
            messageBox.classList.toggle('bg-red-500', isError);
            messageBox.classList.toggle('bg-green-500', !isError);
            messageBox.classList.remove('opacity-0', 'translate-y-[-20px]');
            setTimeout(() => {
                messageBox.classList.add('opacity-0', 'translate-y-[-20px]');
            }, duration);
        }
        
        function updateCircuit(saveHistory = true) {
            if (saveHistory) {
                saveState();
            }
            runSimulation();
            updateTruthTable();
            draw();
            updateHistoryButtons();
        }

        // --- COMPONENT & CIRCUIT CLASSES ---
        
        class Component {
            constructor(type, x, y, id = null) {
                this.id = id !== null ? id : state.nextId++;
                this.type = type;
                this.x = snapToGrid(x);
                this.y = snapToGrid(y);
                this.terminals = [];
                this.isSelected = false;
            }
            isClicked(pos) { return false; }
            draw(isHovered) {}
            getTerminalAt(pos) {
                for (const term of this.terminals) {
                    if (term.isClicked(pos)) return term;
                }
                return null;
            }
        }

        class Terminal {
            constructor(parent, offsetX, offsetY, name, id = null) {
                this.parent = parent;
                this.id = id !== null ? id : state.nextId++;
                this.offsetX = offsetX;
                this.offsetY = offsetY;
                this.name = name;
                this.radius = 6;
                this.net = null;
            }
            get x() { return this.parent.x + this.offsetX; }
            get y() { return this.parent.y + this.offsetY; }
            isClicked(pos) {
                return Math.hypot(pos.x - this.x, pos.y - this.y) < this.radius;
            }
            draw(isHovered) {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
                ctx.fillStyle = isHovered ? colors.terminalHighlight : colors.terminal;
                ctx.fill();
            }
        }

        class Joint {
            constructor(x, y, id = null) {
                this.id = id !== null ? id : state.nextId++;
                this.x = snapToGrid(x);
                this.y = snapToGrid(y);
                this.radius = 5;
                this.net = null;
                this.isSelected = false;
            }
            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
                const netState = this.net ? this.net.state : STATE_FLOAT;
                const colorMap = { [STATE_HIGH]: colors.wireOn, [STATE_LOW]: colors.wireOff, [STATE_FLOAT]: colors.joint, [STATE_ERROR]: colors.wireError };
                ctx.fillStyle = colorMap[netState];
                ctx.fill();

                if (this.isSelected) {
                    ctx.strokeStyle = colors.terminalHighlight;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }
             isClicked(pos) {
                return Math.hypot(pos.x - this.x, pos.y - this.y) < this.radius;
            }
        }

        class Transistor extends Component {
             constructor(type, x, y, id = null) {
                super(type, x, y, id);
                this.width = 40;
                this.height = 60;
                this.terminals.push(new Terminal(this, 0, -this.height / 2, 'source'));
                this.terminals.push(new Terminal(this, 0, this.height / 2, 'drain'));
                this.terminals.push(new Terminal(this, -this.width / 2, 0, 'gate'));
            }
            isClicked(pos) {
                return pos.x > this.x - this.width / 2 && pos.x < this.x + this.width / 2 &&
                       pos.y > this.y - this.height / 2 && pos.y < this.y + this.height / 2;
            }
            draw(isHovered) {
                if (this.isSelected) {
                    ctx.strokeStyle = colors.terminalHighlight;
                    ctx.lineWidth = 2;
                    ctx.strokeRect(this.x - this.width/2 - 4, this.y - this.height/2 - 4, this.width + 8, this.height + 8);
                }

                const gateTerm = this.terminals[2];
                const sourceTerm = this.terminals[0];
                const drainTerm = this.terminals[1];
                const gateState = gateTerm.net ? gateTerm.net.state : STATE_FLOAT;
                let isConducting = (this.type === 'pmos' && gateState === STATE_LOW) || (this.type === 'nmos' && gateState === STATE_HIGH);
                
                ctx.beginPath();
                ctx.moveTo(sourceTerm.x, sourceTerm.y);
                ctx.lineTo(drainTerm.x, drainTerm.y);
                ctx.lineWidth = isConducting ? 6 : 4;
                
                if (isConducting) {
                    let strokeColor;
                    if (this.type === 'nmos') {
                        strokeColor = colors.wireOn; 
                    } else { 
                        strokeColor = colors.pmos;
                        const sourceState = sourceTerm.net ? sourceTerm.net.state : STATE_FLOAT;
                        const drainState = drainTerm.net ? drainTerm.net.state : STATE_FLOAT;
                        if ((sourceState === STATE_HIGH && drainState === STATE_LOW) || (drainState === STATE_HIGH && sourceState === STATE_LOW)) {
                            strokeColor = colors.wireOn; 
                        }
                    }
                    ctx.strokeStyle = strokeColor;
                } else {
                    ctx.strokeStyle = colors.componentStroke;
                }
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(gateTerm.x, gateTerm.y);
                ctx.lineTo(this.x - 5, this.y);
                ctx.lineWidth = 3;
                ctx.strokeStyle = colors.componentStroke;
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(this.x - 5, this.y - 20);
                ctx.lineTo(this.x - 5, this.y + 20);
                ctx.stroke();

                if (this.type === 'pmos') {
                    ctx.beginPath();
                    ctx.arc(this.x - 10, this.y, 5, 0, 2 * Math.PI);
                    ctx.fillStyle = colors.pmos;
                    ctx.fill();
                    
                    ctx.fillStyle = colors.text;
                    ctx.font = 'bold 12px Inter';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('P', this.x, this.y);
                } else { // nmos
                    ctx.fillStyle = colors.text;
                    ctx.font = 'bold 12px Inter';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('N', this.x, this.y);
                }
                this.terminals.forEach(t => t.draw(isHovered && t === isHovered));
            }
        }

        class IOComponent extends Component {
            constructor(type, x, y, id = null, label = null) {
                super(type, x, y, id);
                this.width = 60;
                this.height = 40;
                this.terminals.push(new Terminal(this, this.type === 'input' ? this.width/2 : -this.width/2, 0, 'term'));
                if (type === 'input') {
                    this.state = false; // Corresponds to STATE_LOW
                    this.label = label || state.nextInputLabel;
                    if (!label) state.nextInputLabel = String.fromCharCode(state.nextInputLabel.charCodeAt(0) + 1);
                } else {
                    this.label = label || `Out${state.components.filter(c=>c.type==='output').length + 1}`
                }
            }
            isClicked(pos) {
                return pos.x > this.x - this.width / 2 && pos.x < this.x + this.width / 2 &&
                       pos.y > this.y - this.height / 2 && pos.y < this.y + this.height / 2;
            }
            toggle() {
                if (this.type === 'input') {
                    this.state = !this.state;
                    updateCircuit();
                }
            }
            draw(isHovered) {
                const term = this.terminals[0];
                let netState = STATE_FLOAT;
                if (this.type === 'input') netState = this.state ? STATE_HIGH : STATE_LOW;
                else if (term.net) netState = term.net.state;
                
                const colorMap = { [STATE_HIGH]: colors.wireOn, [STATE_LOW]: colors.wireOff, [STATE_FLOAT]: colors.wireFloat, [STATE_ERROR]: colors.wireError };
                ctx.fillStyle = colorMap[netState];
                ctx.strokeStyle = this.isSelected ? colors.terminalHighlight : colors.componentStroke;
                ctx.lineWidth = this.isSelected ? 2 : 1.5;

                // Draw rounded rectangle body
                const bodyWidth = this.width;
                const bodyHeight = this.height;
                const cornerRadius = 8;
                ctx.beginPath();
                // Custom roundRect path for compatibility
                ctx.moveTo(this.x - bodyWidth / 2 + cornerRadius, this.y - bodyHeight / 2);
                ctx.lineTo(this.x + bodyWidth / 2 - cornerRadius, this.y - bodyHeight / 2);
                ctx.arcTo(this.x + bodyWidth / 2, this.y - bodyHeight / 2, this.x + bodyWidth / 2, this.y - bodyHeight / 2 + cornerRadius, cornerRadius);
                ctx.lineTo(this.x + bodyWidth / 2, this.y + bodyHeight / 2 - cornerRadius);
                ctx.arcTo(this.x + bodyWidth / 2, this.y + bodyHeight / 2, this.x + bodyWidth / 2 - cornerRadius, this.y + bodyHeight / 2, cornerRadius);
                ctx.lineTo(this.x - bodyWidth / 2 + cornerRadius, this.y + bodyHeight / 2);
                ctx.arcTo(this.x - bodyWidth / 2, this.y + bodyHeight / 2, this.x - bodyWidth / 2, this.y + bodyHeight / 2 - cornerRadius, cornerRadius);
                ctx.lineTo(this.x - bodyWidth / 2, this.y - bodyHeight / 2 + cornerRadius);
                ctx.arcTo(this.x - bodyWidth / 2, this.y - bodyHeight / 2, this.x - bodyWidth / 2 + cornerRadius, this.y - bodyHeight / 2, cornerRadius);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                // Draw label and arrow
                ctx.fillStyle = colors.text;
                ctx.font = 'bold 16px Inter';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                let displayText = '';
                if (this.type === 'input') {
                    displayText = `${this.label} >`;
                } else { // output
                    const numericLabel = this.label.replace('Out', '');
                    displayText = `> O${numericLabel}`;
                }
                ctx.fillText(displayText, this.x, this.y);
                
                this.terminals.forEach(t => t.draw(isHovered && t === isHovered));
            }
        }
        
        class PowerComponent extends Component {
            constructor(type, x, y, id = null) {
                super(type, x, y, id);
                this.width = 60;
                this.height = 20;
                this.terminals.push(new Terminal(this, 0, 0, 'out'));
            }
            isClicked(pos) {
                return pos.x > this.x - this.width / 2 && pos.x < this.x + this.width / 2 &&
                       pos.y > this.y - this.height / 2 && pos.y < this.y + this.height / 2;
            }
            draw(isHovered) {
                if (this.isSelected) {
                    ctx.strokeStyle = colors.terminalHighlight;
                    ctx.lineWidth = 2;
                    ctx.strokeRect(this.x - this.width/2 - 4, this.y - this.height/2 - 4, this.width + 8, this.height + 8);
                }

                const color = this.type === 'vdd' ? colors.wireOn : colors.wireOff;
                const label = this.type === 'vdd' ? 'VDD' : 'GND';
                ctx.strokeStyle = color;
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(this.x - this.width/2, this.y);
                ctx.lineTo(this.x + this.width/2, this.y);
                ctx.stroke();
                if (this.type === 'gnd') {
                    for(let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        ctx.moveTo(this.x - (10 - i*5), this.y + 5);
                        ctx.lineTo(this.x + (10 - i*5), this.y + 5);
                        ctx.lineWidth = 2 - i * 0.5;
                        ctx.stroke();
                    }
                }
                ctx.fillStyle = color;
                ctx.font = '12px Inter';
                ctx.textAlign = 'center';
                ctx.fillText(label, this.x, this.y - 15);
                this.terminals.forEach(t => t.draw(isHovered && t === isHovered));
            }
        }

        // --- SIMULATION LOGIC ---
        
        class Net {
            constructor(id) {
                this.id = id;
                this.points = new Set();
                this.state = STATE_FLOAT;
            }
        }

        function runSimulation() {
            // --- Part 1: Netlist Generation ---
            // The first step is to figure out which components are connected together.
            // A "net" is a group of all terminals and joints that are directly wired together.
            // We use a Breadth-First Search (BFS) algorithm to discover these connections.

            const allPoints = [...state.components.flatMap(c => c.terminals), ...state.joints];
            allPoints.forEach(p => p.net = null); // Reset previous simulation results.

            const nets = [];
            let netId = 0;
            const visited = new Set(); // Keep track of points we've already assigned to a net.

            // Iterate through every possible connection point on the canvas.
            for (const startPoint of allPoints) {
                if (visited.has(startPoint)) continue; // If already in a net, skip it.

                // This point is the start of a new, undiscovered net.
                const newNet = new Net(netId++);
                const queue = [startPoint]; // The queue for our BFS.
                visited.add(startPoint);

                // Start the BFS traversal.
                while (queue.length > 0) {
                    const currentPoint = queue.shift();
                    currentPoint.net = newNet; // Assign this point to our new net.
                    newNet.points.add(currentPoint);

                    // Look through all wires to find connections from the current point.
                    for (const wire of state.wires) {
                        let otherPoint = null;
                        if (wire.start === currentPoint) otherPoint = wire.end;
                        if (wire.end === currentPoint) otherPoint = wire.start;

                        // If we found a connected point that we haven't visited, add it to the queue.
                        if (otherPoint && !visited.has(otherPoint)) {
                            visited.add(otherPoint);
                            queue.push(otherPoint);
                        }
                    }
                }
                nets.push(newNet); // Add the completed net to our list of all nets.
            }

            // --- Part 2: Iterative State Solving ---
            // Because the output of one gate can be the input to another, we can't solve the
            // circuit in a single pass. We must iterate multiple times until the state of
            // all nets stabilizes. 20 iterations is more than enough for any reasonable circuit.
            for (let i = 0; i < 20; i++) {
                let changed = false; // Flag to see if any net changes state in this iteration.
                const nextStates = new Map(); // Store the calculated next state for each net.

                // For each net, determine what its state should be in the next step.
                for (const net of nets) {
                    let hasVdd = false;       // Is the net directly connected to a HIGH source (VDD, Input)?
                    let hasGnd = false;       // Is the net directly connected to a LOW source (GND, Input)?
                    let pullsHigh = false;    // Is a transistor trying to connect this net to a HIGH source?
                    let pullsLow = false;     // Is a transistor trying to connect this net to a LOW source?
                    let hasErrorPull = false; // Is a transistor trying to connect this net to an ERROR source?

                    // Analyze every point within the current net.
                    for (const point of net.points) {
                        if (point instanceof Terminal) {
                            const parent = point.parent;
                            
                            // Check for direct connections to power sources or inputs. These are the strongest drivers.
                            if (parent.type === 'vdd' || (parent.type === 'input' && parent.state)) hasVdd = true;
                            if (parent.type === 'gnd' || (parent.type === 'input' && !parent.state)) hasGnd = true;
                            
                            // Check for connections made through transistors.
                            if (parent instanceof Transistor) {
                                const gateNet = parent.terminals[2].net;
                                if (!gateNet) continue; // Skip if the gate isn't connected.

                                const gateState = gateNet.state;
                                // Determine if the transistor is conducting based on its type and gate voltage.
                                const isConducting = (parent.type === 'pmos' && gateState === STATE_LOW) || (parent.type === 'nmos' && gateState === STATE_HIGH);

                                if (isConducting) {
                                    // Find what the other side of the transistor (source/drain) is connected to.
                                    const otherTerm = point.name === 'source' ? parent.terminals[1] : parent.terminals[0];
                                    const otherNet = otherTerm.net;
                                    if (otherNet) {
                                        // The other side's state determines what this transistor is trying to do to our current net.
                                        if (otherNet.state === STATE_HIGH) pullsHigh = true;
                                        else if (otherNet.state === STATE_LOW) pullsLow = true;
                                        else if (otherNet.state === STATE_ERROR) hasErrorPull = true;
                                    }
                                }
                            }
                        }
                    }
                    
                    // --- Part 3: State Determination Logic ---
                    // Based on the flags we've set, determine the final state of this net.
                    let newState = STATE_FLOAT; // Default to floating (high impedance).

                    if (hasVdd && hasGnd) { // Direct short to both VDD and GND.
                        newState = STATE_ERROR;
                    } else if (hasVdd) { // Direct connection to VDD is the strongest driver.
                        newState = STATE_HIGH;
                    } else if (hasGnd) { // Direct connection to GND is the second strongest.
                        newState = STATE_LOW;
                    } else if (hasErrorPull) { // Propagate any error states.
                        newState = STATE_ERROR;
                    } else if (pullsHigh && pullsLow) { // A transistor is pulling high AND another is pulling low. This is a short circuit.
                        newState = STATE_ERROR;
                    } else if (pullsHigh) { // Only being pulled high.
                        newState = STATE_HIGH;
                    } else if (pullsLow) { // Only being pulled low.
                        newState = STATE_LOW;
                    }

                    // Model capacitance: if a net is not being driven by anything, it should hold its previous state.
                    if (newState === STATE_FLOAT && (net.state === STATE_HIGH || net.state === STATE_LOW)) {
                        newState = net.state;
                    }
                    
                    nextStates.set(net, newState);
                }

                // Apply the calculated next states to all nets.
                for (const net of nets) {
                    const newState = nextStates.get(net);
                    if (net.state !== newState) {
                        net.state = newState;
                        changed = true; // Mark that the circuit has not yet stabilized.
                    }
                }

                // If no nets changed state during this entire iteration, the circuit is stable and we can stop.
                if (!changed) break;
            }
        }

        // --- TRUTH TABLE LOGIC ---
        function updateTruthTable() {
            const inputs = state.components.filter(c => c.type === 'input').sort((a, b) => a.label.localeCompare(b.label));
            const outputs = state.components.filter(c => c.type === 'output').sort((a, b) => a.label.localeCompare(b.label));

            if (inputs.length === 0 || inputs.length > 8) {
                truthTableContainer.innerHTML = `<p class="p-2 text-gray-400 text-center">${inputs.length > 8 ? 'Too many inputs for truth table.' : 'Add inputs to see truth table.'}</p>`;
                return;
            }

            const originalInputStates = inputs.map(i => i.state);
            
            let tableHtml = '<table><thead><tr>';
            inputs.forEach(i => tableHtml += `<th>${i.label}</th>`);
            outputs.forEach(o => tableHtml += `<th>${o.label}</th>`);
            tableHtml += '</tr></thead><tbody>';

            const numRows = 1 << inputs.length;
            for (let i = 0; i < numRows; i++) {
                tableHtml += '<tr>';
                for (let j = 0; j < inputs.length; j++) {
                    const val = (i >> (inputs.length - 1 - j)) & 1;
                    inputs[j].state = !!val; // Modify main state for this row's simulation
                    tableHtml += `<td class="${val ? 'state-high' : 'state-low'}">${val}</td>`;
                }

                runSimulation(); // Run simulation on the main state

                // Read outputs directly from the main state
                outputs.forEach(o => {
                    const netState = o.terminals[0].net ? o.terminals[0].net.state : STATE_FLOAT;
                    let val = '?';
                    let className = 'state-float';
                    if (netState === STATE_HIGH) { val = '1'; className = 'state-high'; }
                    else if (netState === STATE_LOW) { val = '0'; className = 'state-low'; }
                    else if (netState === STATE_ERROR) { val = 'X'; className = 'state-error'; }
                    tableHtml += `<td class="${className}">${val}</td>`;
                });
                tableHtml += '</tr>';
            }

            tableHtml += '</tbody></table>';
            truthTableContainer.innerHTML = tableHtml;

            // Restore original state to the main canvas
            inputs.forEach((input, i) => input.state = originalInputStates[i]);
            runSimulation(); // Run simulation one last time to update visuals
        }

        // --- DRAWING LOGIC ---
        function drawGrid() {
            ctx.fillStyle = colors.grid;
            for (let x = 0; x < canvas.width; x += GRID_SIZE) {
                for (let y = 0; y < canvas.height; y += GRID_SIZE) {
                    ctx.beginPath();
                    ctx.arc(x, y, 1, 0, 2 * Math.PI);
                    ctx.fill();
                }
            }
        }

        function drawOrthogonalWire(p1, p2, color) {
            const dx = Math.abs(p1.x - p2.x);
            const dy = Math.abs(p1.y - p2.y);

            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);

            if (dx > dy) { // Prefer H-V-H routing
                const midX = snapToGrid((p1.x + p2.x) / 2);
                ctx.lineTo(midX, p1.y);
                ctx.lineTo(midX, p2.y);
            } else { // Prefer V-H-V routing
                const midY = snapToGrid((p1.y + p2.y) / 2);
                ctx.lineTo(p1.x, midY);
                ctx.lineTo(p2.x, midY);
            }
            
            ctx.lineTo(p2.x, p2.y);
            ctx.strokeStyle = color;
            ctx.lineWidth = 4;
            ctx.stroke();
        }

        function draw() {
            ctx.fillStyle = '#111827';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            drawGrid();
            
            const colorMap = { [STATE_HIGH]: colors.wireOn, [STATE_LOW]: colors.wireOff, [STATE_FLOAT]: colors.wireFloat, [STATE_ERROR]: colors.wireError };
            
            state.wires.forEach(wire => {
                const netState = wire.start.net ? wire.start.net.state : STATE_FLOAT;
                drawOrthogonalWire(wire.start, wire.end, colorMap[netState]);
            });

            if (state.mode === 'wire' && state.wiringStartPoint) {
                const snappedMousePos = { x: snapToGrid(state.mouseX), y: snapToGrid(state.mouseY) };
                drawOrthogonalWire(state.wiringStartPoint, snappedMousePos, colors.terminalHighlight);
            }

            const allConnectablePoints = [
                ...state.components.flatMap(c => c.terminals),
                ...state.joints
            ];
            const hoveredPoint = getHoveredConnectable(allConnectablePoints, {x: state.mouseX, y: state.mouseY});

            state.components.forEach(comp => comp.draw(hoveredPoint && hoveredPoint.parent === comp ? hoveredPoint : null));
            state.joints.forEach(j => j.draw());

            if (state.selectionBox) {
                if (state.mode === 'delete') {
                    ctx.fillStyle = 'rgba(239, 68, 68, 0.3)'; // red-500 with opacity
                    ctx.strokeStyle = '#ef4444'; // red-500
                } else {
                    ctx.fillStyle = colors.selection;
                    ctx.strokeStyle = colors.terminalHighlight;
                }
                ctx.fillRect(state.selectionBox.x, state.selectionBox.y, state.selectionBox.w, state.selectionBox.h);
                ctx.strokeRect(state.selectionBox.x, state.selectionBox.y, state.selectionBox.w, state.selectionBox.h);
            }
        }

        // --- EVENT HANDLERS ---
        function setMode(newMode) {
            state.mode = newMode;
            state.placingComponentType = null;
            toolSelect.classList.toggle('active', newMode === 'select');
            toolWire.classList.toggle('active', newMode === 'wire');
            toolDelete.classList.toggle('active', newMode === 'delete');
            paletteItems.forEach(p => p.classList.remove('selected'));
            canvas.classList.toggle('cursor-trash', newMode === 'delete');
        }

        function getHoveredConnectable(points, pos) {
            for (const p of points) {
                if (p.isClicked(pos)) return p;
            }
            return null;
        }

        function getSelectedItems() {
            return [...state.components, ...state.joints].filter(item => item.isSelected);
        }

        function clearSelection() {
            state.components.forEach(c => c.isSelected = false);
            state.joints.forEach(j => j.isSelected = false);
        }

        canvas.addEventListener('mousedown', (e) => {
            const pos = getMousePos(e);
            if (state.placingComponentType) {
                let newComp;
                const type = state.placingComponentType;
                if (type === 'pmos' || type === 'nmos') newComp = new Transistor(type, pos.x, pos.y);
                else if (type === 'input' || type === 'output') newComp = new IOComponent(type, pos.x, pos.y);
                else if (type === 'vdd' || type === 'gnd') newComp = new PowerComponent(type, pos.x, pos.y);
                if (newComp) state.components.push(newComp);
                setMode('select');
                updateCircuit();
                return;
            }

            const allPoints = [...state.components.flatMap(c => c.terminals), ...state.joints];
            const point = getHoveredConnectable(allPoints, pos);
            const comp = state.components.find(c => c.isClicked(pos));

            if (state.mode === 'wire') {
                if (point) {
                    state.wiringStartPoint = point;
                }
            } else if (state.mode === 'select') {
                state.dragStartX = pos.x;
                state.dragStartY = pos.y;
                state.dragging = true;

                if (comp) {
                    if (!comp.isSelected && !e.shiftKey) {
                        clearSelection();
                    }
                    comp.isSelected = !e.shiftKey || !comp.isSelected;
                } else {
                    if (!e.shiftKey) clearSelection();
                    state.selectionBox = { x: pos.x, y: pos.y, w: 0, h: 0 };
                }
                draw();
            } else if (state.mode === 'delete') {
                 let itemClicked = false;
                 if (point && point instanceof Joint) {
                    state.joints = state.joints.filter(j => j.id !== point.id);
                    state.wires = state.wires.filter(w => w.start.id !== point.id && w.end.id !== point.id);
                    itemClicked = true;
                }
                for (let i = state.wires.length - 1; i >= 0; i--) {
                    const wire = state.wires[i];
                    if (distToSegment(pos, wire.start, wire.end) < 5) {
                        state.wires.splice(i, 1);
                        itemClicked = true;
                        break; // Only delete one wire per click
                    }
                }
                if (!itemClicked && comp) {
                    state.components = state.components.filter(c => c.id !== comp.id);
                    const termIds = new Set(comp.terminals.map(t => t.id));
                    state.wires = state.wires.filter(w => !termIds.has(w.start.id) && !termIds.has(w.end.id));
                    itemClicked = true;
                }

                if (itemClicked) {
                    updateCircuit();
                } else {
                    // Start box selection for delete
                    state.dragStartX = pos.x;
                    state.dragStartY = pos.y;
                    state.dragging = true;
                    state.selectionBox = { x: pos.x, y: pos.y, w: 0, h: 0 };
                }
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            const pos = getMousePos(e);
            state.mouseX = pos.x;
            state.mouseY = pos.y;

            if (state.dragging) {
                if (state.selectionBox) {
                    state.selectionBox.w = pos.x - state.dragStartX;
                    state.selectionBox.h = pos.y - state.dragStartY;
                    draw();
                } else {
                    const dx = snapToGrid(pos.x) - snapToGrid(state.dragStartX);
                    const dy = snapToGrid(pos.y) - snapToGrid(state.dragStartY);

                    getSelectedItems().forEach(item => {
                        item.x += dx;
                        item.y += dy;
                    });

                    state.dragStartX = snapToGrid(pos.x);
                    state.dragStartY = snapToGrid(pos.y);
                    updateCircuit(false);
                }
            } else {
                canvas.classList.toggle('cursor-grab', state.mode === 'select' && !!state.components.find(c => c.isClicked(pos)));
                const allPoints = [...state.components.flatMap(c => c.terminals), ...state.joints];
                canvas.classList.toggle('cursor-crosshair', state.mode === 'wire' && !!getHoveredConnectable(allPoints, pos));
                draw();
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (state.dragging) {
                const pos = getMousePos(e);
                const distMoved = Math.hypot(pos.x - state.dragStartX, pos.y - state.dragStartY);
                
                if (state.selectionBox) {
                    const box = state.selectionBox;
                    const x1 = Math.min(box.x, box.x + box.w);
                    const x2 = Math.max(box.x, box.x + box.w);
                    const y1 = Math.min(box.y, box.y + box.h);
                    const y2 = Math.max(box.y, box.y + box.h);

                    if (state.mode === 'delete') {
                        const idsToDelete = new Set();
                        state.components.forEach(c => {
                            if (c.x >= x1 && c.x <= x2 && c.y >= y1 && c.y <= y2) {
                                idsToDelete.add(c.id);
                                c.terminals.forEach(t => idsToDelete.add(t.id));
                            }
                        });
                        state.joints.forEach(j => {
                            if (j.x >= x1 && j.x <= x2 && j.y >= y1 && j.y <= y2) {
                                idsToDelete.add(j.id);
                            }
                        });
                        
                        if (idsToDelete.size > 0) {
                            state.components = state.components.filter(c => !idsToDelete.has(c.id));
                            state.joints = state.joints.filter(j => !idsToDelete.has(j.id));
                            state.wires = state.wires.filter(w => !idsToDelete.has(w.start.id) && !idsToDelete.has(w.end.id));
                            updateCircuit();
                        }
                    } else if (state.mode === 'select') {
                        [...state.components, ...state.joints].forEach(item => {
                            if (item.x >= x1 && item.x <= x2 && item.y >= y1 && item.y <= y2) {
                                item.isSelected = true;
                            }
                        });
                        draw();
                    }
                    state.selectionBox = null;
                } else {
                    const selected = getSelectedItems();
                    if (distMoved < 5 && selected.length === 1 && selected[0] instanceof IOComponent && selected[0].type === 'input') {
                        selected[0].toggle();
                    } else if (distMoved > 5) {
                        updateCircuit(); // Save move to history
                    }
                }
            }
            state.dragging = false;

            if (state.wiringStartPoint) {
                const pos = getMousePos(e);
                const allPoints = [...state.components.flatMap(c => c.terminals), ...state.joints];
                const endPoint = getHoveredConnectable(allPoints, pos);

                if (endPoint && endPoint !== state.wiringStartPoint) {
                    state.wires.push({ start: state.wiringStartPoint, end: endPoint });
                } else {
                    let bestWire = null;
                    let minDistance = Infinity;
                    for(const wire of state.wires) {
                        const dist = distToSegment(pos, wire.start, wire.end);
                        if (dist < minDistance) {
                            minDistance = dist;
                            bestWire = wire;
                        }
                    }

                    if (bestWire && minDistance < 10) {
                        const jointPos = getClosestPointOnOrthogonalSegment(pos, bestWire.start, bestWire.end);
                        const newJoint = new Joint(jointPos.x, jointPos.y);
                        state.joints.push(newJoint);
                        
                        state.wires = state.wires.filter(w => w !== bestWire);
                        state.wires.push({ start: bestWire.start, end: newJoint });
                        state.wires.push({ start: newJoint, end: bestWire.end });
                        state.wires.push({ start: state.wiringStartPoint, end: newJoint });
                    }
                }
                state.wiringStartPoint = null;
                updateCircuit();
            }
        });
        
        canvas.addEventListener('mouseleave', () => {
             if (state.dragging && !state.selectionBox) {
                 updateCircuit(); // Save state if dragging off canvas
             }
             state.dragging = false;
             state.wiringStartPoint = null;
             state.selectionBox = null;
             draw();
        });

        toolSelect.addEventListener('click', () => setMode('select'));
        toolWire.addEventListener('click', () => setMode('wire'));
        toolDelete.addEventListener('click', () => setMode('delete'));
        
        paletteItems.forEach(item => {
            item.addEventListener('click', () => {
                setMode('select');
                state.placingComponentType = item.dataset.type;
                paletteItems.forEach(p => p.classList.remove('selected'));
                item.classList.add('selected');
            });
        });
        
        clearButton.addEventListener('click', () => {
            const modalHTML = `
                <div id="confirm-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                    <div class="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-sm">
                        <h3 class="text-lg font-bold text-white mb-4">Clear Canvas?</h3>
                        <p class="text-gray-300 mb-6">Are you sure you want to delete all components and wires? This action cannot be undone.</p>
                        <div class="flex justify-end gap-4">
                            <button id="modal-cancel" class="px-4 py-2 rounded-lg bg-gray-600 hover:bg-gray-500 text-white">Cancel</button>
                            <button id="modal-confirm" class="px-4 py-2 rounded-lg bg-red-700 hover:bg-red-600 text-white">Confirm & Clear</button>
                        </div>
                    </div>
                </div>
            `;
            document.body.insertAdjacentHTML('beforeend', modalHTML);

            const modal = document.getElementById('confirm-modal');
            document.getElementById('modal-cancel').onclick = () => modal.remove();
            document.getElementById('modal-confirm').onclick = () => {
                state.components = [];
                state.wires = [];
                state.joints = [];
                state.nextInputLabel = 'A';
                updateCircuit();
                modal.remove();
            };
        });
        
        toggleTruthTableButton.addEventListener('click', () => {
            truthTablePanel.classList.toggle('hidden');
            toggleTruthTableButton.classList.toggle('active');
        });

        // --- HISTORY (UNDO/REDO) LOGIC ---
        function saveState() {
            history.splice(historyIndex + 1);
            
            const currentState = JSON.stringify({
                components: state.components.map(c => ({
                    id: c.id, type: c.type, x: c.x, y: c.y, label: c.label || null, 
                    state: c.state,
                    terminals: c.terminals.map(t => ({ id: t.id, name: t.name, offsetX: t.offsetX, offsetY: t.offsetY }))
                })),
                joints: state.joints.map(j => ({ id: j.id, x: j.x, y: j.y })),
                wires: state.wires.map(w => ({ startId: w.start.id, endId: w.end.id })),
                nextInputLabel: state.nextInputLabel,
                nextId: state.nextId
            });

            if (history.length > 0 && history[historyIndex] === currentState) {
                return;
            }

            history.push(currentState);
            historyIndex = history.length - 1;
        }

        function loadState(stateData) {
            state.components = [];
            state.wires = [];
            state.joints = [];
            state.nextId = stateData.nextId || 0;
            state.nextInputLabel = stateData.nextInputLabel || 'A';

            const pointMap = new Map();

            stateData.components.forEach(cData => {
                let comp;
                if (cData.type === 'pmos' || cData.type === 'nmos') {
                    comp = new Transistor(cData.type, cData.x, cData.y, cData.id);
                } else if (cData.type === 'input' || cData.type === 'output') {
                    comp = new IOComponent(cData.type, cData.x, cData.y, cData.id, cData.label);
                    if (cData.type === 'input') comp.state = cData.state;
                } else if (cData.type === 'vdd' || cData.type === 'gnd') {
                    comp = new PowerComponent(cData.type, cData.x, cData.y, cData.id);
                }
                
                if (comp && cData.terminals && cData.terminals.length === comp.terminals.length) {
                    comp.terminals = cData.terminals.map(tData => {
                        const newTerm = new Terminal(comp, tData.offsetX, tData.offsetY, tData.name, tData.id);
                        pointMap.set(newTerm.id, newTerm);
                        return newTerm;
                    });
                }
                if (comp) state.components.push(comp);
            });

            (stateData.joints || []).forEach(jData => {
                const joint = new Joint(jData.x, jData.y, jData.id);
                state.joints.push(joint);
                pointMap.set(joint.id, joint);
            });

            stateData.wires.forEach(wData => {
                const startPoint = pointMap.get(wData.startId);
                const endPoint = pointMap.get(wData.endId);
                if (startPoint && endPoint) {
                    state.wires.push({ start: startPoint, end: endPoint });
                }
            });

            updateCircuit(false);
        }

        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                loadState(JSON.parse(history[historyIndex]));
            }
        }

        function redo() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                loadState(JSON.parse(history[historyIndex]));
            }
        }

        function updateHistoryButtons() {
            undoButton.disabled = historyIndex <= 0;
            redoButton.disabled = historyIndex >= history.length - 1;
        }

        undoButton.addEventListener('click', undo);
        redoButton.addEventListener('click', redo);


        // --- SAVE/LOAD/COPY/PASTE LOGIC ---
        saveButton.addEventListener('click', () => {
            try {
                const saveData = JSON.parse(history[historyIndex]);
                const jsonString = JSON.stringify(saveData, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'cmos-design.json';
                a.click();
                URL.revokeObjectURL(url);
                showMessage("Design saved successfully!", 3000);
            } catch (error) {
                showMessage("Failed to save design.", 3000, true);
                console.error("Save error:", error);
            }
        });

        loadButton.addEventListener('click', () => {
            fileInput.click();
        });

        fileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const loadedData = JSON.parse(e.target.result);
                    history = [JSON.stringify(loadedData)];
                    historyIndex = 0;
                    loadState(loadedData);
                    showMessage("Design loaded successfully!", 3000);
                } catch (error) {
                    showMessage("Failed to load or parse file.", 3000, true);
                    console.error("Load error:", error);
                } finally {
                    event.target.value = '';
                }
            };
            reader.readAsText(file);
        });

        function copySelection() {
            const selectedItems = getSelectedItems();
            if (selectedItems.length === 0) {
                showMessage("Nothing selected to copy.", 2000, true);
                return;
            }

            const selectedIds = new Set(selectedItems.map(item => item.id));

            const center = selectedItems.reduce((acc, item) => ({ x: acc.x + item.x, y: acc.y + item.y }), {x: 0, y: 0});
            center.x /= selectedItems.length;
            center.y /= selectedItems.length;

            clipboard = {
                components: state.components.filter(c => c.isSelected).map(c => ({
                    id: c.id,
                    type: c.type, 
                    x: c.x - center.x, 
                    y: c.y - center.y, 
                    label: c.label || null,
                    terminals: c.terminals.map(t => ({ id: t.id }))
                })),
                joints: state.joints.filter(j => j.isSelected).map(j => ({
                    id: j.id,
                    x: j.x - center.x, 
                    y: j.y - center.y
                })),
                wires: state.wires.filter(w => selectedIds.has(w.start.id) && selectedIds.has(w.end.id))
                                   .map(w => ({ startId: w.start.id, endId: w.end.id }))
            };
            showMessage("Selection copied!", 2000);
        }

        function pasteFromClipboard() {
            if (!clipboard) {
                showMessage("Clipboard is empty.", 2000, true);
                return;
            }

            clearSelection();
            const idMap = new Map();
            const newItems = [];

            const pasteCenter = { x: snapToGrid(state.mouseX), y: snapToGrid(state.mouseY) };

            clipboard.components.forEach(cData => {
                const oldId = cData.id;
                let newComp;
                const newX = pasteCenter.x + cData.x;
                const newY = pasteCenter.y + cData.y;

                if (cData.type === 'pmos' || cData.type === 'nmos') {
                    newComp = new Transistor(cData.type, newX, newY);
                } else if (cData.type === 'input' || cData.type === 'output') {
                    newComp = new IOComponent(cData.type, newX, newY, null, null);
                } else if (cData.type === 'vdd' || cData.type === 'gnd') {
                    newComp = new PowerComponent(cData.type, newX, newY);
                }
                
                if (newComp) {
                    newComp.isSelected = true;
                    state.components.push(newComp);
                    newItems.push(newComp);
                    idMap.set(oldId, newComp.id);
                    cData.terminals.forEach((tData, i) => {
                        idMap.set(tData.id, newComp.terminals[i].id);
                    });
                }
            });

            clipboard.joints.forEach(jData => {
                const oldId = jData.id;
                const newJoint = new Joint(pasteCenter.x + jData.x, pasteCenter.y + jData.y);
                newJoint.isSelected = true;
                state.joints.push(newJoint);
                newItems.push(newJoint);
                idMap.set(oldId, newJoint.id);
            });
            
            const allNewPoints = [...state.components, ...state.joints].reduce((map, item) => {
                map.set(item.id, item);
                if(item.terminals) item.terminals.forEach(t => map.set(t.id, t));
                return map;
            }, new Map());

            clipboard.wires.forEach(wData => {
                const newStartId = idMap.get(wData.startId);
                const newEndId = idMap.get(wData.endId);
                const startPoint = allNewPoints.get(newStartId);
                const endPoint = allNewPoints.get(newEndId);
                if (startPoint && endPoint) {
                    state.wires.push({ start: startPoint, end: endPoint });
                }
            });

            updateCircuit();
        }

        copyButton.addEventListener('click', copySelection);
        pasteButton.addEventListener('click', pasteFromClipboard);

        window.addEventListener('keydown', (e) => {
            if (e.ctrlKey || e.metaKey) {
                switch (e.key.toLowerCase()) {
                    case 'c':
                        copySelection();
                        e.preventDefault();
                        break;
                    case 'v':
                        pasteFromClipboard();
                        e.preventDefault();
                        break;
                    case 'z':
                        undo();
                        e.preventDefault();
                        break;
                    case 'y':
                        redo();
                        e.preventDefault();
                        break;
                }
            }
        });
        
        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            updateCircuit(false);
        }
        
        function getClosestPointOnOrthogonalSegment(p, v, w) {
            const dx = Math.abs(v.x - w.x);
            const dy = Math.abs(v.y - w.y);
            let path;

            if (dx > dy) { // H-V-H path
                const midX = snapToGrid((v.x + w.x) / 2);
                path = [{x:v.x, y:v.y}, {x:midX, y:v.y}, {x:midX, y:w.y}, {x:w.x, y:w.y}];
            } else { // V-H-V path
                const midY = snapToGrid((v.y + w.y) / 2);
                path = [{x:v.x, y:v.y}, {x:v.x, y:midY}, {x:w.x, y:midY}, {x:w.x, y:w.y}];
            }
            
            let closestPoint = null;
            let min_dist = Infinity;

            for(let i=0; i<path.length-1; i++) {
                const p1 = path[i];
                const p2 = path[i+1];
                const l2 = (p1.x - p2.x)**2 + (p1.y - p2.y)**2;
                if (l2 == 0) {
                    const dist = Math.hypot(p.x - p1.x, p.y - p1.y);
                     if (dist < min_dist) {
                        min_dist = dist;
                        closestPoint = {x: p1.x, y: p1.y};
                    }
                    continue;
                }
                let t = ((p.x - p1.x) * (p2.x - p1.x) + (p.y - p1.y) * (p2.y - p1.y)) / l2;
                t = Math.max(0, Math.min(1, t));
                const currentClosestPoint = {x: p1.x + t * (p2.x - p1.x), y: p1.y + t * (p2.y - p1.y)};
                const dist = Math.hypot(p.x - currentClosestPoint.x, p.y - currentClosestPoint.y);

                if (dist < min_dist) {
                    min_dist = dist;
                    closestPoint = currentClosestPoint;
                }
            }
            return closestPoint;
        }
        
        function distToSegment(p, v, w) {
            const closestPoint = getClosestPointOnOrthogonalSegment(p, v, w);
            return Math.hypot(p.x - closestPoint.x, p.y - closestPoint.y);
        }

        window.addEventListener('resize', resizeCanvas);
        
        // Initial setup
        resizeCanvas();
        saveState(); // Save the initial empty state
        updateHistoryButtons();
        showMessage("Select a component from the palette to begin!", 3000);
    </script>
</body>
</html>
